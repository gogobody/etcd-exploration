## 1 CAP
* Consistency 一致性，这里指的是强一致性，原子读写
* Availability 可用性
* Partition tolerance 分区容错性

以上只能最多满足两个

## 2 一致性
### 2.1 以数据为中心的一致性模型
#### 2.1.1 Strong Consistency 强一致性
强一致性也称原子一致性、可线性化(Linearizability)
1. 任何一次读都能读到某个数据的最近一次写的数据
2. 系统中所有进程看到的操作顺序都与全局时钟下的顺序一致

通常情况，单机遵守严格一致性，但是分布式系统很难为每个操作都分配一个准确的全局时间戳，因此严格一致性只是理论的一致性模型

然而，通常的编程方式使语句执行的确切时间并不重要，事件的读写顺序是非常重要的，可以使用信号量等同步方法进行同步操作，如单机多线程环境下实际上是一种顺序一致性模型

#### 2.1.2 Sequential Consistency 顺序一致性
顺序一致性也称可序列化
1. 顺序一致性放弃了全局时钟的的约束，它是指所有进程都有相同的顺序看到所有的修改
2. 读操作未必能及时得到此前其他进程对同一数据的写更新，但是每个进程读到的该数据不同值的顺序是一致的
3. 它只要求系统中所有的进程达成自己认为的一致性就可以了，不要求和全局顺序保持一致

![avatar](./img/1.webp)
* x 和 y 的初始值为 0
* Write(x,4)代表写入 x=4，Read(y,2)为读取 y =2

符合每个进程的顺序
```
Write(y,2), Read(x,0), Write(x,4), Read(y,2)
```
全局顺序
```
Write(y,2), Write(x,4), Read(x,0)(这里不符合全局一致性了，因为x已经被更新了), Read(y,2)
```

#### 2.1.3 Causal Consistency  因果一致性
todo

#### 2.1.4 Serializable Consistency 串行化一致性
todo

### 2.2 以用户为中心的一致性模型
#### 2.2.1 Eventual Consistency 最终一致性
最终用户在延迟了一段时间（不一致窗口）后看到了最新更新的数据的值

### 2.3 复制状态机
![avatar](./img/2.png)
* 一致性模块接受客户端命令追加到自己的操作日志，然后与其他服务器的一致性模块进行通讯保证执行的命令和顺序相同。
* 假设： 如果状态机拥有相同的初始状态，接收到相同的命令，处理这些命令的顺序也相同，那么最终状态就会相同。

### 2.4 拜占庭将军
至少 N/2 + 1， 不代表满足这个数量就万无一失

## Paxos
todo

## Raft

