# mvcc（状态机存储）概述
## 并发控制
在数据库领域，并发控制是一个很具有挑战性的话题。常见的并发控制方式包括悲观锁、乐观锁和多版本并发控制。但是无论是悲观锁还是乐观锁，它们都不是真正的锁概念，而是用来描述锁类别的『设计思想』。

## 悲观锁
悲观并发控制（又称悲观锁）指的是对数据竞争持悲观消极的态度，默认数据被外界访问时，必然会产生冲突，所以在数据处理的整个过程中会对数据加各种锁来实现并发控制，保证同一时间只有一个线程可以访问到数据。如果一个事务执行过程中对某行数据应用了锁，那么只有在这个事务将锁释放之后，其他事务才能够执行与该锁冲突的操作。由于加锁机制是一种预防性的版本控制，读操作会阻塞写操作，写操作也会阻塞读操作，当锁的粒度较大、时间较长时并发性能就比较差，主要用于数据竞争激烈、写多读少的并发环境。

## 乐观锁
乐观并发控制（又称乐观锁）是相对悲观锁而言，假设多用户并发的事务在处理时彼此之间不会互相影响，所以不会对数据加锁。在提交更新的数据之前，每个事务都会检查在该事务读取数据之后，有没有其它事务又修改了该数据。如果有其它事务对数据进行了修改，那么正在提交的事务会进行回滚。乐观锁多用于数据冲突较少的环境，偶尔回滚事务的成本要比读取数据时锁定数据的成本低很多，在这种情况下乐观锁可以获得更高的吞吐量。

## MVCC
多版本并发控制（Multi-Version Concurrency Control , MVCC）是一种无锁事务机制，可以把 MVCC 理解为乐观并发控制思想的一种实现方法，它能够与悲观锁很好地结合以增加事务的并发量。MVCC 的每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适（要么是最新版本，要么是指定版本）的结果直接返回 。通过这种方式，我们就不需要关注读写操作之间的数据冲突。因此，如何管理和高效地选取数据的版本就成了 MVCC 需要解决的主要问题。

# 核心数据结构
由于存在较多的数据结构，这里简述一下其之间的关系, ()里的结构是其接口
```go
//可以管理 watcher 实例的 store
watchableStore
{
    *store // 内嵌了 store
}

// mvcc.store 相关，对外提供服务的接口
store(kv)
{
	ReadView    // 只读事物视图(kv 内嵌了该结构)
	WriteView   //读写事物视图 (kv 内嵌了该结构)
	b       backend.Backend  // 后端存储相关
	kvindex index(treeindex)  // 索引相关
	le lease.Lessor  // 租约相关
}

// backend 索引相关
treeIndex(Index)  BTree 索引树，用来找 key 对应的 KeyIndex, 内存维护

keyIndex
{
    generation
}

// backend store 相关
backend(Backend)  // 底层存储与上层解耦
{
    readTx(ReadTx)  // 只读事务
    batchTx(BatchTx) // 读写事务
    {
        ReadTx // 内嵌了 ReadTx
    }
    db *bolt.DB  // 底层持久化数据库


}
```
